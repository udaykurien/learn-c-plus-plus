#include <iostream>
#include <string>

//Function template declaration/prototype
template <typename T> 
T maximum(T a, T b);

int main () {

    /*
    Creating a function template for the following kind of overloads:
    Consider the following function overloads:
    ---------------------------------------------------------------------
    (1)
    int max(int a, int b) {
        return (a>b)? a:b;
    }

    (2)
    double max (double a, double b) {
        return (a>b)?a:b;
    }

    (3)
    std::string_view max(std::string_view a, std::string_view b) {
        return (a>b)? a:b;
    }
    ---------------------------------------------------------------------
    
    It's function template is:
    (note the similarities in structure)
    ---------------------------------------------------------------------
    template <typename T> T maximum(T a, T b) {
        return (a > b) ? a :b;
    }
    ---------------------------------------------------------------------

    Note:
    Function templates are not "real" C++ code. They're just the blue print that the compiler uses to generate the actual functions. The number and type of functions generated depend up the parameter types passed in the function calls. After generation of the functions, the source code file is then compiled into its binary form / object files.

    You can check the creating of the relevant functions using a debugging tool, or check out https://cpinsights.io
    */

    // Function calls (compiler will encounter this and generate appropriate functions based on the template)
    int a{10}, b{23};
    double c{34.7}, d{23.4};
    std::string e{"hello"}, f{"world"};

    std::cout << "max(int): " << maximum(a,b) << std::endl; //1st version created
    std::cout << "max(double): " << maximum(c,d) << std::endl; //2nd version created
    std::cout << "max(string): " << maximum(e,f) << std::endl; //3rd version created

    // You can also store the output of the call in an appropriate variable
    int result = maximum(10,20);
    auto result2 = maximum(33.56, 76.29);
    
    /*
    int x{25};
    double y{3.7};
    auto result3 = maximum(x,y);
    This will fail, because the type placeholder in the function template is the same for each parameter and the return. Because of this, the compiler doesn't have a blue print on handling 2 different parameter types and therefore won't know what to do, resulting in a compiler error.
    */

    return 0;

}

//Function template definition
template <typename T> 
T maximum(T a, T b) {
    return (a > b) ? a :b;
}
/*
- template :    keyword for defining template
- T :           placeholder for the types used in the function
- maximum :     name of the function
- a & b :       parameters of type T
- {} :          contains function definition/logic

Combined all of these form the blueprint of the function.
Based on the argument types, C++ will automatically deduce the precise function from its blueprint by assigning the appropriate type to 'T'.
The parameters and return, all have to be of the same type.

template     <typename T>   T               maximum         (T a, T b)
keyword         auto-type   return type     function name   Type(T) and parameter(a,b)
*/

/*
Some final notes:
- Function templates are just blueprints. They are not real C++ code consumed by the compiler. The compiler generates real C++ code by looking at the arguments you call your function template with.
- The real C++ function generated by the compiler is called a template instance.
- A template instance will be reused when a similar function call (argument types) is issued. No duplicates are generated by the compiler.
- To the types passed into the function MUST support the logic/operations contained within the function definition. eg. We can set up a function template to multiply two arguments. This will run fine for numeric data types such as int, double and float but might fail (compiler error) for non numeric data types such as strings.
*/