#include <iostream>
#include <string>

// Class and headers
class Dog{
    public:
        //Constructors
        // Dog() = default; // default explicitly specified below
        Dog();
        Dog(std::string_view name_param, std::string_view breed_param, int age_param);
        //Destructors
        ~Dog();
        //Print function
        void print_info();
        //Other functions
        Dog* set_name (const std::string& name);
        Dog* set_breed (const std::string& breed);
        Dog* set_age (int age);
    private:
        std::string name;
        std::string breed;
        int * p_age{nullptr};
};

// Class header defintions
// Constructor (default)
Dog::Dog(){
    name = "None";
    breed = "None";
    p_age = new int;
    *p_age = 0;
    std::cout << " > Dog object - " << name << ", created at memory address (this) - " << this << std::endl; //Using 'this' to return memory address of object which is being generated by the constructor method.
    // If the 'this' operator did not exist, there would be no way to get the object address from within the object class. We would be compelled to get the object address using the ampersand sign in main (or another function external to the dog class), in whose scope the dog object resides.
}
// Constructor
Dog::Dog(std::string_view name_param, std::string_view breed_param, int age_param) {
    name = name_param; //alt: this->name = name; (if member variable and param are both use identical identifiers(name) (see setter set_name for demonstration))
    breed = breed_param;
    p_age = new int; //
    *p_age = age_param; 
    std::cout << " > Dog object - " << name << ", created at memory address (this) - " << this << std::endl; //Using 'this' to return memory address of object which is being generated by the constructor method
}
// Destructor
Dog::~Dog(){
    delete p_age;
    std::cout << " > Dog object - " << name << ", destroyed from memory address (this) - " << this << std::endl; // Using 'this' to get memory address of object being destroyed
}
// Print function
void Dog::print_info(){
    std::cout << "************************" << std::endl;
    std::cout << "PRINT INFO" << std::endl;
    std::cout << "Dog (" << this << "): " << std::endl;
    std::cout << "Name - " << name << std::endl;
    std::cout << "Breed - " << breed << std::endl;
    std::cout << "age - " << *p_age << std::endl;
    std::cout << "**************************" << std::endl;
    
}
// Other methods (pointer return)
Dog* Dog::set_name(const std::string& name){
    //name = name; // Compiler error as compiler can't distinguish member variable from parameter
                  // or compiler assigns value of variable name back to itself |hahahah!|
    this->name = name; // 'this' pointer, with pointer access notation (->) to member variable (name) lets the compiler distinguish between the member variable 'name' & the parameter 'name'.
    return this;
}
Dog* Dog::set_breed(const std::string& breed){
    this->breed = breed;
    return this;
}
Dog* Dog::set_age(int age){
    *(this->p_age) = age; // explanation: derefence(member pointer p_age, present in obj pointed to by pointer 'this')
    // alternative: *p_age = age;
    return this; 
}
/*
// Other methods (reference return)
Dog& Dog::set_name(const std::string& name){
    this->name = name; 
    return *this; //Dereference and return
}
Dog& Dog::set_breed(const std::string& breed){
    this->breed = breed;
    return *this;
}
Dog& Dog::set_age(int age){
    *(this->p_age) = age;
    return *this;
*/


int main () {

    /*
    The this pointer (22:11:03):
    'this' is a special pointer that is mantained  by C++ to help us manipulate the current object.
    The current object, is the object on which a method is being executed.

    or

    Each class member function contains a hidden pointer called 'this'. That pointer contains the address of the current object, for which the method is being executed. This also applies to constructors and destructors.

    or

    'this' points to the current object being manipulated by a function of the class object in the C++ runtime.

    or

    'this' is the pointer to or the memory address of the current object.

    Uses:
    1. Point to current object being manipulated by class method.
    2. Disambiguate between class member variable and class method parameter of same name.
    3. Daisy chained calls using pointers. 
    */

    // 1. Point to current object being manipulated by class method.
    Dog obj1 {"Doggy1","Huskie",5};
    Dog obj2 = {"Doggy2","Huskie",5};
    Dog obj3 = Dog("Doggy3","Huskie",9);
    Dog obj4("Doggy4","Huskie",9);
    Dog obj5;

    // 2. Disambiguate between class member variable and class method parameter of same name.
    Dog obj6;
    obj6.set_name("Rufus");
    obj6.set_breed("Malamute");
    obj6.set_age(10);

    // 3. Daisy chained calls using pointers.
    Dog *p_obj7 = new Dog("Milou","shepherd",3);
    std::cout << "Original object (obj7): " << std::endl;
    (*p_obj7).print_info();
    //Chain calling via pointers (starting from pointer to dog object)
    p_obj7->set_name("Mario")->set_breed("Terrier")->set_age(6);
    std::cout << "Object (obj7) after pointer daisy chaining setters: " << std::endl;
    (*p_obj7).print_info();
    /*
    - The dog pointer points to the dog object in the heap.
    - Using pointer access notation we call a setter function (set_name)
    - Becase of our method definition, the setter will return the pointer back to the dog object in the heap.
    - Using pointer access notation we call the next setter.
    - As long as the next setter and subsequent methods are set up to return the dog object pointer, we can continue to chain methods using pointer access notation.
    - We must terminate the chain if we call a method that does not return a pointer to the object (as pointer access notation will no longer have a class pointer to access and hence the chain can not be continued).
    */

   //Chain calling via pointers (starting from dog object)
   // Notice the first setter is now called using dot notation instead of pointer access notation
   // The remianing setters are called with pointer access notation as each setter returns an object pointer.
   obj6.set_name("Ruffles")->set_breed("Pomerenian")->set_age(1);

    /*
    //Chain calling via references (mthods return object references):
    //For this to work, the setter functions must be set to return object references

    //Chain calling via references (starting with object pointer)
    p_obj7->set_name("Mario").set_breed("Terrier").set_age(6);

    //Chain calling via references (starting with object)
    obj6.set_name("Mario").set_breed("Terrier").set_age(6);
    */

    delete p_obj7;
    
    std::cout << "------------\nEnd of program\n----------- " << std::endl;
    return 0;

}
