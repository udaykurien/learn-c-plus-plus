#include <iostream>
#include <string>

// Class and headers
class Dog{
    public:
        //Constructors
        // Dog() = default; // default explicitly specified below
        Dog();
        Dog(std::string_view name_param, std::string_view breed_param, int age_param);
        //Destructors
        ~Dog();
        //Other functions
        Dog* set_name (const std::string& name);
        Dog* set_breed (const std::string& breed);
        Dog* set_age (int age);
    private:
        std::string name;
        std::string breed;
        int * p_age{nullptr};
};

// Class header defintions
// Constructor (default)
Dog::Dog(){
    name = "None";
    breed = "None";
    p_age = new int;
    *p_age = 0;
    std::cout << " > Dog object - " << name << ", created at memory address (this) - " << this << std::endl; //Using 'this' to return memory address of object which is being generated by the constructor method
}
// Constructor
Dog::Dog(std::string_view name_param, std::string_view breed_param, int age_param) {
    name = name_param;
    breed = breed_param;
    p_age = new int; //
    *p_age = age_param; 
    std::cout << " > Dog object - " << name << ", created at memory address (this) - " << this << std::endl; //Using 'this' to return memory address of object which is being generated by the constructor method
}
// Destructor
Dog::~Dog(){
    delete p_age;
    std::cout << " > Dog object - " << name << ", destroyed from memory address (this) - " << this << std::endl; // Using this to get memory address of object being destroyed
}
// Other methods (pointer return)
Dog* Dog::set_name(const std::string& name){
    //name = name; // Compiler error as compiler can't distinguish member variable from parameter
    this->name = name; // 'this' pointer, with pointer access notation (->) to member variable (name) lets the compiler distinguish between the member variable 'name' & the parameter 'name'.
    return this;
}
Dog* Dog::set_breed(const std::string& breed){
    this->breed = breed;
    return this;
}
Dog* Dog::set_age(int age){
    *(this->p_age) = age;
    return this;
}
/*
// Other methods (reference return)
Dog& Dog::set_name(const std::string& name){
    this->name = name; 
    return *this; //Dereference and return
}
Dog& Dog::set_breed(const std::string& breed){
    this->breed = breed;
    return *this;
}
Dog& Dog::set_age(int age){
    *(this->p_age) = age;
    return *this;
*/


int main () {

    /*
    The this pointer (22:11:03):
    'this' is a special pointer that is mantained  by C++ to help us manipulate the current object.
    The current object, is the object on which a method is being executed.

    or

    Each class member function contains a hidden pointer called 'this'. That pointer contains the address of the current object, for which the method is being executed. This also applies to constructors and destructors.

    or

    'this' points to the current object being manipulated by a function of the class object in the C++ runtime.

    or

    'this' is the pointer to or the memory address of the current object.

    Uses:
    1. Point to current object being manipulated by class method.
    2. Disambiguate between class member variable and class method parameter of same name.
    3. Daisy chained calls using pointers. 
    */

    // 1. Point to current object being manipulated by class method.
    Dog obj1 {"Doggy1","Huskie",5};
    Dog obj2 = {"Doggy2","Huskie",5};
    Dog obj3 = Dog("Doggy3","Huskie",9);
    Dog obj4("Doggy3","Huskie",9);
    Dog obj5;

    // 2. Disambiguate between class member variable and class method parameter of same name.
    std::cout << std::endl;
    obj1.set_name("Rufus");
    obj1.set_breed("Malamute");
    obj1.set_age(10);

    // 3. Daisy chained calls using pointers.
    std::cout << std::endl;
    Dog *p_obj6 = new Dog("Milou","shepherd",3);
    //Chain calling via pointers
    p_obj6->set_name("Mario")->set_breed("Terrier")->set_age(6);
    /*
    - The dog pointer points to the dog object in the heap.
    - Using pointer access notation we call a setter function (set_name)
    - Becase of our method definition, the setter will return the pointer back to the dog object in the heap.
    - Using pointer access notation we call the next setter.
    - As long as the next setter and subsequent methods are set up to return the dog object pointer, we can continue to chain methods using pointer access notation.
    - We must terminate the chain if we call a method that does not return a pointer to the object (as pointer access notation will no longer have a class pointer to access and hence the chain can not be continued).
    */

   /*
   Chain calling via references (mthods return object references):
   p_obj6->set_name("Mario").set_breed("Terrier").set_age(6);
   */

   delete p_obj6;
    

    return 0;

}
